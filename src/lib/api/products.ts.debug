import slugify from 'slugify';

// Get API base URL from environment variables with fallback
const getApiBaseUrl = () => {
  // Use environment variable if available
  if (import.meta.env.VITE_API_URL) {
    return import.meta.env.VITE_API_URL;
  }
  
  // Fallback to current origin if in browser
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }
  
  // Default fallback for SSR or other contexts
  return '';
};

export interface PageGenerationParams {
  productId: string;
  title: string;
  description: string;
  price: number;
  image: string;
  brandName: string;
  brandId: string | null;
  categories: Array<{ id: string; name: string }>;
}

// Cr√©e une page produit sur le serveur
export const createProductPage = async (params: PageGenerationParams): Promise<{ success: boolean; message: string; slug?: string }> => {
  try {
    const apiBaseUrl = getApiBaseUrl();
    // Envoyer une requ√™te au backend pour cr√©er la page
    const response = await fetch(`${apiBaseUrl}/api/products/create-page`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(params),
    });

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error creating product page:', error);
    return { success: false, message: 'Erreur lors de la cr√©ation de la page produit.' };
  }
};

// Supprime une page produit sur le serveur
export const deleteProductPage = async (productId: string, title: string): Promise<{ success: boolean; message: string }> => {
  try {
    const slug = slugify(title, { lower: true });
    const apiBaseUrl = getApiBaseUrl();
    
    // Envoyer une requ√™te au backend pour supprimer la page
    const response = await fetch(`${apiBaseUrl}/api/products/delete-page`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ productId, title, slug }),
    });

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error deleting product page:', error);
    return { success: false, message: 'Erreur lors de la suppression de la page produit.' };
  }
};

// V√©rifie si une page produit existe
export const checkProductPageExists = async (productIds: string[]): Promise<Record<string, boolean>> => {
  try {
    const apiBaseUrl = getApiBaseUrl();
    
    // Envoyer une requ√™te au backend pour v√©rifier l'existence des pages
    const response = await fetch(`${apiBaseUrl}/api/products/check-pages`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ productIds }),
    });

    const data = await response.json();
    return data.exists || {};
  } catch (error) {
    console.error('Error checking product pages:', error);
    return {};
  }
};

// R√©cup√®re les descriptions personnalis√©es des produits depuis les fichiers .tsx
export const fetchProductDescriptions = async (): Promise<Record<string, string>> => {
  try {
    const apiBaseUrl = getApiBaseUrl();
    console.log("üîç R√©cup√©ration des descriptions de produits depuis l'API...");
    console.log("üåê URL de l'API:", `${apiBaseUrl}/api/products/descriptions`);
    
    // Appeler l'API pour r√©cup√©rer les descriptions
    const response = await fetch(`${apiBaseUrl}/api/products/descriptions`);
    
    if (!response.ok) {
      console.error(`‚ùå Erreur HTTP: ${response.status} - ${await response.text()}`);
      throw new Error(`Erreur HTTP: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Validation des donn√©es re√ßues
    if (!data || typeof data !== 'object') {
      console.error(`‚ùå Format de r√©ponse invalide:`, data);
      return {};
    }
    
    // V√©rifier que le champ descriptions existe et est un objet
    if (!data.descriptions || typeof data.descriptions !== 'object') {
      console.error(`‚ùå Champ descriptions manquant ou invalide:`, data);
      return {};
    }
    
    const descriptions = data.descriptions || {};
    
    // Normaliser les identifiants - convertir tous les IDs en cha√Ænes de caract√®res
    const normalizedDescriptions: Record<string, string> = {};
    Object.entries(descriptions).forEach(([id, desc]) => {
      // Convertir l'ID en cha√Æne de caract√®res
      const stringId = String(id);
      // V√©rifier que la description est une cha√Æne de caract√®res
      const stringDesc = typeof desc === 'string' ? desc : String(desc);
      normalizedDescriptions[stringId] = stringDesc;
    });
    
    console.log("‚úÖ Descriptions r√©cup√©r√©es:", Object.keys(normalizedDescriptions).length);
    
    // Debug: v√©rification des types de cl√©s et valeurs
    if (Object.keys(normalizedDescriptions).length > 0) {
      const sampleKeys = Object.keys(normalizedDescriptions).slice(0, 3);
      console.log("üîë Type des cl√©s:", typeof sampleKeys[0]);
      console.log("üìÑ √âchantillon des cl√©s:", sampleKeys);
      
      sampleKeys.forEach(key => {
        console.log(`üì¶ Description pour ${key}: ${normalizedDescriptions[key].substring(0, 30)}...`);
      });
    } else {
      console.log("‚ö†Ô∏è Aucune description r√©cup√©r√©e!");
    }
    
    return normalizedDescriptions;
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des descriptions:', error);
    return {};
  }
}; 