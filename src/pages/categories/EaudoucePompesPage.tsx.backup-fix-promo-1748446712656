import slugify from 'slugify';

import PromoBadge from '@/components/PromoBadge';import { getPriceIdForProduct } from "@/lib/stripe/getPriceIdFromSupabase";

// Helper function to safely handle HTML descriptions
const getSafeHtmlDescription = (description: string | undefined): string => {
  if (!description) return "Description non disponible";
  
  // V√©rifier si la cha√Æne contient des entit√©s HTML √©chapp√©es
  const hasEscapedHtml = description.includes('&lt;') || description.includes('&gt;');
  
  // V√©rifier si c'est du HTML non √©chapp√©
  const hasHtmlContent = /<[a-z][\s\S]*>/i.test(description);
  
  // Si la description contient des caract√®res HTML √©chapp√©s, on doit les transformer en HTML r√©el
  if (hasEscapedHtml) {
    // On remplace les entit√©s HTML courantes
    let decodedHtml = description
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, ' ');
    
    return decodedHtml;
  }
  
  // If it's already HTML content, return it as is
  if (hasHtmlContent) return description;
  
  // Otherwise treat it as plain text
  return description.trim() || "Description non disponible";
};
import { useState, useEffect, useRef } from "react";
import { useParams, useSearchParams, Link as RouterLink } from "react-router-dom";
import { CheckCircle, ChevronDown, Filter, Star, ShoppingCart, X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { Checkbox } from "@/components/ui/checkbox";
import Header from "@/components/Header";
import Footer from "@/components/Footer";
import { fetchShopifyProducts, ShopifyProduct } from "@/lib/api/shopify";
import { fetchCategoriesForProducts } from "@/lib/api/product-categories";
import { fetchCategories, Category } from "@/lib/api/categories";
import { fetchBrands, Brand, fetchBrandsForProducts } from "@/lib/api/brands";
import { EditableText } from "@/components/EditableText";
import { EditableImage } from "@/components/EditableImage";
import { useEditStore } from "@/stores/useEditStore";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/components/ui/use-toast";
import FloatingHeader from "@/components/admin/FloatingHeader";
import { useImageUpload } from "@/hooks/useImageUpload";
import { useCartStore } from "@/stores/useCartStore";
import { fetchProductDescriptions } from "@/lib/api/products";

// üîç Trouve la sous-cat√©gorie √† partir du param√®tre `souscategorie` dans l'URL ou du slug direct
const findMatchingSubCategory = (subCategories: Category[], slugParam: string): Category | undefined => {
  return subCategories.find(cat => {
    const cleanSlug = cat.slug?.split("?")[0];
    const redirectSlug = cat.redirect_url?.split("souscategorie=")[1];
    return slugParam === cleanSlug || slugParam === redirectSlug;
  });
};

// Type √©tendu pour les produits Shopify dans cette page
type ExtendedShopifyProduct = ShopifyProduct & {
  // Propri√©t√©s optionnelles suppl√©mentaires pour l'affichage
  onSale?: boolean;
  salePrice?: string;
};

// Donn√©es de filtres
const filters = {
  price: { min: 0, max: 300 },
  stock: true,
  promos: false,
};

// Types de cat√©gories
const categories = {
  "decorations": {
    title: "D√©corations",
    description: "Embellissez votre aquarium avec notre s√©lection de d√©corations naturelles et artificielles.",
    bannerImage: "/placeholder.svg"
  },
  "pumps": {
    title: "Pompes & Filtration",
    description: "Solutions de filtration et pompes pour maintenir une eau propre et bien oxyg√©n√©e.",
    bannerImage: "/placeholder.svg"
  },
  "heating": {
    title: "Chauffages & Ventilation",
    description: "Maintenez la temp√©rature id√©ale pour vos esp√®ces aquatiques.",
    bannerImage: "/placeholder.svg"
  },
  "biochemical": {
    title: "Produits Bio-Chimiques",
    description: "Produits de traitement d'eau et solutions pour l'√©quilibre biologique de votre aquarium.",
    bannerImage: "/placeholder.svg"
  },
  "lighting": {
    title: "√âclairages",
    description: "Syst√®mes d'√©clairage adapt√©s pour la croissance des plantes et le bien-√™tre des poissons.",
    bannerImage: "/placeholder.svg"
  },
  "maintenance": {
    title: "Entretiens & Nettoyages",
    description: "Accessoires et produits pour l'entretien facile de votre aquarium.",
    bannerImage: "/placeholder.svg"
  },
  "food": {
    title: "Alimentation",
    description: "Nourriture de qualit√© pour tous types de poissons et invert√©br√©s.",
    bannerImage: "/placeholder.svg"
  },
  "packs": {
    title: "Packs Mensuels",
    description: "Abonnements pratiques pour recevoir r√©guli√®rement vos produits essentiels.",
    bannerImage: "/placeholder.svg"
  }
};

// Fonction pour trouver les sous-cat√©gories
const findSubCategories = (allCategories: Category[], parentId: string | null) => {
  return allCategories.filter(cat => cat.parent_id === parentId);
};

const CategoryPage = () => {
// Ajout d'un √©tat local pour stocker les prix promos des produits sans variante
  const [promoPrices, setPromoPrices] = useState<Record<string, any>>({});

  useEffect(() => {
    // Pr√©charger les prix promos pour les produits sans variante
    const fetchPromos = async () => {
      const promos: Record<string, any> = {};
      for (const p of filteredProducts) {
        if (!p.hasVariant) {
          const promo = await getDiscountedPrice(p.id);
          if (promo && promo.discount_percentage) {
            promos[p.id] = promo;
          }
        }
      }
      setPromoPrices(promos);
    };
    fetchPromos();
  }, [filteredProducts]);

  // Nettoyage et normalisation du slug pour √©viter les probl√®mes de comparaison
  const rawSlug = useParams<{ slug: string }>()?.slug || "eaudoucepompes";
  const currentSlug = rawSlug.split("?")[0]; // on enl√®ve les √©ventuels param√®tres
  
  // Ajoute ceci :
  const normalizedSlug = currentSlug.trim().toLowerCase().replace(/\W+/g, "");

  console.log("üîé currentSlug =", currentSlug);
  console.log("üßΩ normalizedSlug =", normalizedSlug);

  // Et modifie les conditions comme ceci :
  const isEauDouce = normalizedSlug.includes("eaudoucepompes");
  const isEauMer = normalizedSlug.includes("eaudemerpompes");

  console.log("üíß isEauDouce:", isEauDouce);
  console.log("üåä isEauMer:", isEauMer);
  
  // Test logs
  console.log("üß™ Normalized slug = ", normalizedSlug);
  console.log("üß™ isEauDouce:", isEauDouce);
  console.log("üß™ isEauMer:", isEauMer); 
  
  const [searchParams] = useSearchParams();
  const initialSubCategorySlug = searchParams.get("souscategorie");
  console.log("üì• Param√®tre 'souscategorie' de l'URL:", initialSubCategorySlug);
   
  const [priceRange, setPriceRange] = useState<number[]>([0, 800]);
  const [priceInput, setPriceInput] = useState<number[]>([0, 800]);
  const [mobileFiltersOpen, setMobileFiltersOpen] = useState(false);
  const [selectedBrandIds, setSelectedBrandIds] = useState<string[]>([]);
  const [inStock, setInStock] = useState(true);
  const [promoOnly, setPromoOnly] = useState(false);
  const [selectedSubCategories, setSelectedSubCategories] = useState<string[]>([]);
  
  // Nouveaux √©tats pour les produits Shopify
  const [products, setProducts] = useState<ExtendedShopifyProduct[]>([]);
  const [linkedCategories, setLinkedCategories] = useState<Record<string, string[]>>({});
  const [linkedBrands, setLinkedBrands] = useState<Record<string, string | null>>({});
  const [filteredProducts, setFilteredProducts] = useState<ExtendedShopifyProduct[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [allCategories, setAllCategories] = useState<Category[]>([]);
  const [parentCategory, setParentCategory] = useState<Category | null>(null);
  const [subCategories, setSubCategories] = useState<Category[]>([]);
  const [brands, setBrands] = useState<Brand[]>([]);
  const [brandsError, setBrandsError] = useState<string | null>(null);
  const [brandsLoading, setBrandsLoading] = useState(false);

  // Add this near the other state declarations
  const [productDescriptions, setProductDescriptions] = useState<Record<string, string>>({});

  // Add this near the other state declarations
  const hasAppliedInitialSubCategory = useRef(false);
  
  // Pagination states
  const ITEMS_PER_PAGE = 12; // Ajuste selon ton design
  const [currentPage, setCurrentPage] = useState(1);

  const paginatedProducts = filteredProducts.slice(
    (currentPage - 1) * ITEMS_PER_PAGE,
    currentPage * ITEMS_PER_PAGE
  );

  const totalPages = Math.ceil(filteredProducts.length / ITEMS_PER_PAGE);

  // Reset page when filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [filteredProducts]);

  // √âtat pour le mode √©dition et toast notifications
  const { isEditMode } = useEditStore();
  const { toast } = useToast();
  
  // √âtat pour stocker le contenu √©ditable
  const [categoryTitle, setCategoryTitle] = useState<string>("D√©corations Eau Douce");
  const [categoryDescription, setCategoryDescription] = useState<string>(
    "Embellissez votre aquarium d'eau douce avec nos d√©corations sp√©cialement s√©lectionn√©es."
  );
  const [categoryBannerImage, setCategoryBannerImage] = useState<string>("/placeholder.svg");
  
  // Obtenir les informations de la cat√©gorie
  const categoryInfo = {
    title: categoryTitle,
    description: categoryDescription,
    bannerImage: categoryBannerImage
  };

  // Log au montage du composant
  useEffect(() => {
    console.log("üîÅ CategoryPage mont√© - slug =", currentSlug);
  }, []);
  
  // Debug useEffect pour confirmer le chargement avec les param√®tres URL
  useEffect(() => {
    console.log("üìç CategoryPage charg√© avec slug =", currentSlug, "et souscategorie =", initialSubCategorySlug);
  }, [currentSlug, initialSubCategorySlug]);

  // Charger les marques depuis Supabase
  useEffect(() => {
    const loadBrands = async () => {
      try {
        setBrandsLoading(true);
        const brandsData = await fetchBrands();
        setBrands(brandsData);
        setBrandsError(null);
      } catch (err) {
        console.error("Erreur lors du chargement des marques:", err);
        setBrandsError("Impossible de charger les marques.");
      } finally {
        setBrandsLoading(false);
      }
    };

    loadBrands();
  }, []);

  // Charger les produits et les cat√©gories li√©es
  useEffect(() => {
    console.log("üöÄ D√©but du chargement des produits pour le slug:", currentSlug);
    
    const loadProductsAndCategories = async () => {
      console.log("üöÄ D√©but de loadProductsAndCategories()");
      try {
        setIsLoading(true);

        // Charger tous les produits Shopify
        console.log("üì§ Avant l'appel fetchShopifyProducts()");
        const allProducts = await fetchShopifyProducts();
        console.log("üõí Produits Shopify r√©cup√©r√©s:", allProducts);
        
        // Convertir les produits au format √©tendu
        const extendedProducts: ExtendedShopifyProduct[] = Array.isArray(allProducts) 
          ? allProducts.map(product => ({
              ...product,
              onSale: false // Par d√©faut, pas en promotion
            })) : [];
        
        console.log("üì¶ Produits √©tendus:", extendedProducts);
        setProducts(extendedProducts);

        if (extendedProducts.length === 0) {
          console.warn("‚ö†Ô∏è Aucun produit r√©cup√©r√© de Shopify !");
          setError("Aucun produit disponible.");
          setIsLoading(false);
          return;
        }

        // Charger les cat√©gories li√©es pour ces produits
        const productIds = extendedProducts.map(p => p.id.toString());
        console.log("üîë IDs des produits √† rechercher:", productIds);
        const categoriesByProduct = await fetchCategoriesForProducts(productIds);
        console.log("üîó Cat√©gories par produit:", categoriesByProduct);
        setLinkedCategories(categoriesByProduct);

        // Charger les marques li√©es pour ces produits
        const brandsByProduct = await fetchBrandsForProducts(productIds);
        console.log("üè∑Ô∏è Marques par produit:", brandsByProduct);
        setLinkedBrands(brandsByProduct);

        // Charger toutes les cat√©gories depuis Supabase
        const categoriesData = await fetchCategories();
        console.log("üìö Toutes les cat√©gories r√©cup√©r√©es:", categoriesData);
        setAllCategories(categoriesData);

        // Trouver la cat√©gorie m√®re par son slug
        const parentCategory = categoriesData.find(
          (cat) => cat.slug === currentSlug
        );
        
        console.log("üéØ Cat√©gorie m√®re trouv√©e via slug:", parentCategory);
        
        if (!parentCategory) {
          console.error("‚ùå Cat√©gorie non trouv√©e pour ce slug:", currentSlug);
          // Pour aider au d√©bogage, affichons les slugs disponibles
          console.log("üîç Slugs disponibles:", categoriesData.map(cat => cat.slug));
          setError("Cat√©gorie non trouv√©e.");
          setIsLoading(false);
          return;
        }
        
        setParentCategory(parentCategory);
        
        // Trouver les sous-cat√©gories par parent_id
        const childCategories = findSubCategories(categoriesData, parentCategory.id);
        console.log("üåø Sous-cat√©gories trouv√©es:", childCategories);
        
        // Nettoyage des slugs de sous-cat√©gorie pour supprimer les √©ventuels param√®tres URL
        const cleanedChildCategories = childCategories.map((cat) => ({
          ...cat,
          slug: cat.slug.split("?")[0],
        }));
        console.log("‚úÖ Slugs nettoy√©s :", cleanedChildCategories.map(c => c.slug));
        setSubCategories(cleanedChildCategories);
        console.log("üì• Sous-cat√©gories assign√©es :", cleanedChildCategories);
        
        // R√©cup√©rer les IDs des sous-cat√©gories ET du parent
        // Pour accepter les produits li√©s soit au parent soit aux enfants
        const categoryIds = [parentCategory.id, ...cleanedChildCategories.map(cat => cat.id)].filter(Boolean);
        console.log("üîë IDs des cat√©gories (parent + enfants):", categoryIds);

        // Filtrer les produits qui appartiennent √† la cat√©gorie parent ou √† ses sous-cat√©gories
        // Et qui correspondent aux marques s√©lectionn√©es
        let filtered = extendedProducts.filter((product) => {
          const productId = product.id.toString();
          const linked = categoriesByProduct[productId] || [];
          const productBrandId = brandsByProduct[productId];
          
          console.log(`üîé Produit ${product.title} (ID: ${productId}):`);
          console.log(`üîó Li√© aux cat√©gories:`, linked);
          console.log(`üè∑Ô∏è Li√© √† la marque:`, productBrandId);
          
          const matchSubCategory = selectedSubCategories.length === 0
            ? linked.some((catId) => categoryIds.includes(catId))
            : linked.some((catId) => selectedSubCategories.includes(catId));
          
          const matchBrand = selectedBrandIds.length === 0
            ? true
            : productBrandId && selectedBrandIds.includes(productBrandId);
          
          const matchPrice = 
            parseFloat(product.price) >= priceRange[0] &&
            parseFloat(product.price) <= priceRange[1];

          const matchStock = !inStock || product.stock > 0;

          const matchPromo = !promoOnly || (product.onSale === true);
          
          console.log(`‚úÖ Correspond aux cat√©gories ? ${matchSubCategory}`);
          console.log(`‚úÖ Correspond aux marques ? ${matchBrand}`);
          console.log(`‚úÖ Correspond au prix ? ${matchPrice}`);
          console.log(`‚úÖ Correspond au stock ? ${matchStock}`);
          console.log(`‚úÖ Correspond aux promos ? ${matchPromo}`);
          
          return matchSubCategory && matchBrand && matchPrice && matchStock && matchPromo;
        });

        console.log("üõí Produits filtr√©s:", filtered);
        setFilteredProducts(filtered);
        setError(null);
      } catch (err) {
        console.error("‚ùå Erreur lors du chargement:", err);
        setError("Impossible de charger les produits. Veuillez r√©essayer plus tard.");
      } finally {
        setIsLoading(false);
      }
    };

    loadProductsAndCategories();
  }, [currentSlug, selectedSubCategories, selectedBrandIds, priceRange, inStock, promoOnly]);

  // R√©cup√©rer les descriptions des produits
  useEffect(() => {
    if (products.length === 0) return;

    const loadProductDescriptions = async () => {
      try {
        console.log("üîÑ Chargement des descriptions pour", products.length, "produits...");
        
        // Extraire les IDs des produits pour n'obtenir que les descriptions n√©cessaires
        const productIds = products.map(p => p.id.toString());
        
        // Appel de la fonction fetchProductDescriptions avec les IDs sp√©cifiques
        const descriptions = await fetchProductDescriptions(productIds);
        console.log("üìã Descriptions re√ßues:", Object.keys(descriptions).length);
        
        // V√©rifier les correspondances
        const foundIds = Object.keys(descriptions);
        const matchRate = foundIds.length > 0 ? 
          Math.round((foundIds.length / productIds.length) * 100) : 0;
        
        console.log(`üìä Taux de correspondance: ${foundIds.length}/${productIds.length} (${matchRate}%)`);
        
        setProductDescriptions(descriptions);
      } catch (error) {
        console.error("‚ùå Erreur lors du chargement des descriptions:", error);
      }
    };

    loadProductDescriptions();
  }, [products]);

  // S√©lectionner automatiquement la sous-cat√©gorie depuis l'URL
  useEffect(() => {
    if (hasAppliedInitialSubCategory.current) return;
    if (!initialSubCategorySlug) {
      console.log("‚ö†Ô∏è Aucun slug 'souscategorie' trouv√© dans l'URL.");
      return;
    }

    if (!Array.isArray(subCategories) || subCategories.length === 0) {
      console.log("‚è≥ En attente de sous-cat√©gories valides...");
      return;
    }

    console.log("üì• Param√®tre 'souscategorie' de l'URL:", initialSubCategorySlug);
    console.log("üìã Liste des slugs disponibles:", subCategories.map(c => c.slug));

    // üîÅ Patiente un peu avant de chercher la sous-cat√©gorie
    const timeout = setTimeout(() => {
      const match = findMatchingSubCategory(subCategories, initialSubCategorySlug);

      if (match) {
        console.log("‚úÖ Sous-cat√©gorie trouv√©e :", match);
        if (!selectedSubCategories.includes(match.id)) {
          setSelectedSubCategories([match.id]);
          hasAppliedInitialSubCategory.current = true;
        }
      } else {
        console.warn("‚ùå Aucune correspondance pour la sous-cat√©gorie slug :", initialSubCategorySlug);
        console.log("üìä D√©tails de recherche :");
        subCategories.forEach(cat => {
          const cleanSlug = cat.slug?.split("?")[0];
          const redirectSlug = cat.redirect_url?.split("souscategorie=")[1];
          console.log(`  - ${cat.name}: slug=${cleanSlug}, redirectSlug=${redirectSlug}`);
        });
      }
    }, 300); // attends 300ms

    return () => clearTimeout(timeout);
  }, [initialSubCategorySlug, subCategories, selectedSubCategories]);

  // Les filtres sont d√©sactiv√©s pour l'instant
  useEffect(() => {
    // Volontairement vide pour d√©sactiver les filtres
    // tout en conservant l'interface utilisateur
  }, [products]);

  // Effet pour appliquer le debounce au changement de prix
  useEffect(() => {
    const timeout = setTimeout(() => {
      setPriceRange(priceInput);
    }, 500); // 500ms apr√®s l'arr√™t

    return () => clearTimeout(timeout);
  }, [priceInput]);

  // G√©rer les changements de filtres
  const handleBrandToggle = (brandId: string) => {
    setSelectedBrandIds(prev => 
      prev.includes(brandId) 
        ? prev.filter(id => id !== brandId)
        : [...prev, brandId]
    );
  };

  const handleSubCategoryToggle = (subCatId: string) => {
    setSelectedSubCategories((prev) =>
      prev.includes(subCatId)
        ? prev.filter((id) => id !== subCatId)
        : [...prev, subCatId]
    );
  };

  const toggleMobileFilters = () => {
    setMobileFiltersOpen(!mobileFiltersOpen);
  };

  // Fonction pour mettre √† jour le prix
  const handlePriceChange = (value: number[]) => {
    setPriceInput(value);
  };

  // Rendu des √©toiles pour les notes
  const renderStars = (rating: number) => {
    return (
      <div className="flex">
        {[...Array(5)].map((_, i) => (
          <Star
            key={i}
            size={16}
            className={`${
              i < Math.floor(rating) 
                ? "text-yellow-500 fill-yellow-500" 
                : i < rating 
                  ? "text-yellow-500 fill-yellow-500 opacity-50" 
                  : "text-gray-300"
            }`}
          />
        ))}
      </div>
    );
  };

  // Fonction pour mettre √† jour le contenu √©ditable
  const handleTextUpdate = async (newText: string, contentKey: string) => {
    try {
      const trimmedText = newText.trim();
      
      // Mettre √† jour l'√©tat local imm√©diatement
      if (contentKey === `category_${currentSlug}_title`) {
        setCategoryTitle(trimmedText);
      } else if (contentKey === `category_${currentSlug}_description`) {
        setCategoryDescription(trimmedText);
      }
      
      // V√©rifier si l'entr√©e existe d√©j√†
      const { data: existingData } = await supabase
        .from("editable_content")
        .select("content_key")
        .eq("content_key", contentKey)
        .limit(1);
      
      let error;
      
      if (existingData && existingData.length > 0) {
        // Mettre √† jour l'entr√©e existante
        const { error: updateError } = await supabase
          .from("editable_content")
          .update({ content: trimmedText })
          .eq("content_key", contentKey);
          
        error = updateError;
      } else {
        // Cr√©er une nouvelle entr√©e
        const { error: insertError } = await supabase
          .from("editable_content")
          .insert({ content_key: contentKey, content: trimmedText });
          
        error = insertError;
      }

      if (!error) {
        console.log("Mise √† jour r√©ussie pour :", contentKey);
      } else {
        console.error("Erreur lors de la mise √† jour :", error);
        toast({
          title: "Erreur",
          description: "Une erreur est survenue lors de la mise √† jour du contenu",
          variant: "destructive"
        });
      }
    } catch (error) {
      console.error("Erreur inattendue :", error);
      toast({
        title: "Erreur",
        description: "Une erreur inattendue est survenue",
        variant: "destructive"
      });
    }
  };
  
  // Charger le contenu √©ditable depuis Supabase
  useEffect(() => {
    const fetchEditableContent = async () => {
      try {
        const { data, error } = await supabase
          .from("editable_content")
          .select("*")
          .in("content_key", [
            `category_${currentSlug}_title`, 
            `category_${currentSlug}_description`,
            `category_${currentSlug}_banner_image`
          ]);
        
        if (!error && data) {
          data.forEach(item => {
            if (item.content_key === `category_${currentSlug}_title`) {
              setCategoryTitle(item.content);
            } else if (item.content_key === `category_${currentSlug}_description`) {
              setCategoryDescription(item.content);
            } else if (item.content_key === `category_${currentSlug}_banner_image`) {
              setCategoryBannerImage(item.content);
            }
          });
        }
      } catch (error) {
        console.error("Erreur lors du chargement du contenu √©ditable :", error);
      }
    };

    fetchEditableContent();
  }, [currentSlug, isEditMode]);

  // Fonction pour mettre √† jour l'URL de l'image
  const handleImageUpdate = async (newUrl: string, contentKey: string) => {
    try {
      // Mettre √† jour l'√©tat local
      if (contentKey === `category_${currentSlug}_banner_image`) {
        setCategoryBannerImage(newUrl);
      }
      
      // V√©rifier si l'entr√©e existe d√©j√†
      const { data: existingData } = await supabase
        .from("editable_content")
        .select("content_key")
        .eq("content_key", contentKey)
        .limit(1);
      
      let error;
      
      if (existingData && existingData.length > 0) {
        // Mettre √† jour l'entr√©e existante
        const { error: updateError } = await supabase
          .from("editable_content")
          .update({ content: newUrl })
          .eq("content_key", contentKey);
          
        error = updateError;
      } else {
        // Cr√©er une nouvelle entr√©e
        const { error: insertError } = await supabase
          .from("editable_content")
          .insert({ content_key: contentKey, content: newUrl });
          
        error = insertError;
      }

      if (!error) {
        console.log("Mise √† jour de l'image r√©ussie pour :", contentKey);
        toast({
          title: "Image mise √† jour",
          description: "L'image d'arri√®re-plan a √©t√© mise √† jour avec succ√®s",
        });
      } else {
        console.error("Erreur lors de la mise √† jour de l'image :", error);
        toast({
          title: "Erreur",
          description: "Une erreur est survenue lors de la mise √† jour de l'image",
          variant: "destructive"
        });
      }
    } catch (error) {
      console.error("Erreur inattendue :", error);
      toast({
        title: "Erreur",
        description: "Une erreur inattendue est survenue",
        variant: "destructive"
      });
    }
  };

  // Cart functionality
  const { getDiscountedPrice, addItem } = useCartStore();

  // Nouvelle fonction d'ajout au panier compatible variantes
  const handleAddToCart = async (product) => {
    if (!product) return;
    
    // R√©cup√©rer les informations sur les variantes s√©lectionn√©es
    let variant = null;
    let stripePriceId = null;
    let stripeDiscountPriceId = null;
    let finalPrice = product.price;
    let originalPrice = undefined;
    let discountPercentage = undefined;
    let hasDiscountApplied = false;
    
    // V√©rifier s'il y a une r√©duction avec getDiscountedPrice
    const priceInfo = await getDiscountedPrice(product.id);
    
    if (priceInfo) {
      finalPrice = priceInfo.price;
      if (priceInfo.discount_percentage) {
        originalPrice = priceInfo.original_price;
        discountPercentage = priceInfo.discount_percentage;
        stripeDiscountPriceId = priceInfo.stripe_discount_price_id;
        hasDiscountApplied = true;
      }
      // Si pas de promotion mais qu'on a un stripe_discount_price_id, c'est que le prix de base est le promotional
      if (priceInfo.stripe_discount_price_id && !priceInfo.discount_percentage) {
        stripePriceId = priceInfo.stripe_discount_price_id;
      }
    }
    
    // Si on n'a pas encore de stripePriceId, r√©cup√©rer le prix de base
    if (!stripePriceId) {
      const { data: priceIdData } = await supabase
        .from('editable_content')
        .select('content')
        .eq('content_key', `product_${product.id}_stripe_price_id`)
        .single();
      if (priceIdData?.content) {
        stripePriceId = priceIdData.content;
      }
    }
    
    // V√©rifier que nous avons un stripe_price_id valide
    if (!stripePriceId || stripePriceId === "null") {
      console.error(`‚ùå Aucun stripe_price_id trouv√© pour le produit ${product.id}`);
      toast({
        variant: "destructive",
        title: "Erreur de configuration",
        description: "Ce produit n'a pas de prix Stripe configur√©."
      });
      return;
    }
    
    console.log(`‚úÖ stripe_price_id trouv√© pour ${product.id}: ${stripePriceId}`);
    
    // V√©rifier le stock
    const { data: stockData } = await supabase
      .from('editable_content')
      .select('content')
      .eq('content_key', `product_${product.id}_stock`)
      .single();
    
    const stock = stockData ? parseInt(stockData.content) : 0;
    if (stock === 0) {
      toast({
        variant: "destructive",
        title: "Rupture de stock",
        description: "Ce produit est en rupture de stock."
      });
      return;
    }
    
    // Ajouter au panier avec toutes les informations n√©cessaires
    try {
      await addItem({
        id: product.id,
        price: finalPrice,
        title: product.title,
        image_url: product.image,
        quantity: 1,
        variant: variant,
        stripe_price_id: stripePriceId,
        stripe_discount_price_id: stripeDiscountPriceId,
        original_price: originalPrice,
        discount_percentage: discountPercentage,
        has_discount: hasDiscountApplied
      });

      toast({
        title: "Produit ajout√© au panier",
        description: hasDiscountApplied 
          ? `${product.title} a √©t√© ajout√© √† votre panier avec ${discountPercentage}% de r√©duction !`
          : `${product.title} a √©t√© ajout√© √† votre panier.`,
      });
      
      console.log(`‚úÖ Produit ajout√© au panier:`, {
        id: product.id,
        title: product.title,
        price: finalPrice,
        stripe_price_id: stripePriceId,
        has_discount: hasDiscountApplied
      });
    } catch (error) {
      console.error("Erreur lors de l'ajout au panier:", error);
      toast({
        variant: "destructive",
        title: "Erreur",
        description: "Impossible d'ajouter le produit au panier."
      });
    }
  };

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <FloatingHeader />
      
      <div>
      {/* Hero Banner */}
      <div 
        className="relative bg-cover bg-center py-16"
      >
        {isEditMode ? (
          <div className="absolute inset-0 z-0">
            <EditableImage
              imageKey={`category_${currentSlug}_banner_image`}
              initialUrl={categoryBannerImage}
              className="w-full h-full object-cover"
              onUpdate={(newUrl) => handleImageUpdate(newUrl, `category_${currentSlug}_banner_image`)}
            />
            <div className="absolute inset-0 bg-black/50"></div>
          </div>
        ) : (
          <div 
            className="absolute inset-0 bg-cover bg-center" 
            style={{ 
              backgroundImage: `linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(${categoryInfo.bannerImage})` 
            }}
          ></div>
        )}
        
        <div className="container mx-auto text-center text-white relative z-10">
          <h1 className="text-3xl md:text-4xl font-bold mb-2">
            <EditableText
              contentKey={`category_${currentSlug}_title`}
              initialContent={categoryTitle}
              onUpdate={(newText) => handleTextUpdate(newText, `category_${currentSlug}_title`)}
            />
          </h1>
          <p className="max-w-2xl mx-auto mb-8">
            <EditableText
              contentKey={`category_${currentSlug}_description`}
              initialContent={categoryDescription}
              onUpdate={(newText) => handleTextUpdate(newText, `category_${currentSlug}_description`)}
            />
          </p>
          
          {/* Navigation Eau Douce / Eau de Mer */}
          <div className="flex flex-col md:flex-row justify-center gap-4 md:gap-6 mb-6">
            <Button
              asChild
              variant={isEauDouce ? "default" : "outline"}
              className={`min-w-48 h-16 md:h-20 text-lg rounded-xl shadow-md transition-all ${
                isEauDouce
                  ? "bg-primary hover:bg-primary/90"
                  : "bg-background/80 hover:bg-background/90 border-2 text-white hover:text-white"
              }`}
            >
              <a href="/categories/eaudoucepompes" className="flex flex-col items-center justify-center">
                <div className="text-2xl mb-1">üêü</div>
                <span>Eau douce</span>
              </a>
            </Button>
            
            <Button
              asChild
              variant={isEauMer ? "default" : "outline"}
              className={`min-w-48 h-16 md:h-20 text-lg rounded-xl shadow-md transition-all ${
                isEauMer
                  ? "bg-primary hover:bg-primary/90"
                  : "bg-background/80 hover:bg-background/90 border-2 text-white hover:text-white"
              }`}
            >
              <a href="/categories/eaudemerpompes" className="flex flex-col items-center justify-center">
                <div className="text-2xl mb-1">üåä</div>
                <span>Eau de mer</span>
              </a>
            </Button>
          </div>
          
          {/* Breadcrumb navigation removed as requested */}
          </div>
        </div>
      </div>
      
      <main className="flex-grow container mx-auto px-4 py-8">
        {/* Panneau de debug en bas de page */}
        {isEditMode && (
          <div style={{ position: "fixed", bottom: 0, left: 0, background: "#fff", padding: "6px", zIndex: 9999, fontSize: "11px", border: "1px solid #ccc" }}>
            <div>Slug brut : <b>{rawSlug}</b></div>
            <div>Slug nettoy√© : <b>{currentSlug}</b></div>
            <div>Slug normalis√© : <b>{normalizedSlug}</b></div>
            <div>isEauDouce : <b>{isEauDouce.toString()}</b></div>
            <div>isEauMer : <b>{isEauMer.toString()}</b></div>
            <div>Slug sous-cat√©gorie URL : <b>{initialSubCategorySlug}</b></div>
            <div>Sous-cat√©gories charg√©es : {subCategories.length}</div>
            <div>Sous-cat√©gories IDs s√©lectionn√©es : {selectedSubCategories.join(", ")}</div>
            <div>Slugs dispo : {subCategories.map(s => s.slug).join(", ")}</div>
          </div>
        )}
        
        <div className="flex flex-col md:flex-row gap-8">
          {/* Bouton filtre mobile */}
          <div className="md:hidden mb-4">
            <Button 
              onClick={toggleMobileFilters}
              variant="outline" 
              className="w-full flex items-center justify-between"
            >
              <div className="flex items-center">
                <Filter size={18} className="mr-2" />
                Filtres
              </div>
              <ChevronDown size={18} />
            </Button>
          </div>

          {/* Filtres (mobile) */}
          {mobileFiltersOpen && (
            <div className="fixed inset-0 bg-black/50 z-50 md:hidden">
              <div className="bg-white h-full w-4/5 max-w-md p-4 overflow-auto animate-slide-in-right">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="font-bold text-lg">Filtres</h2>
                  <Button variant="ghost" size="sm" onClick={toggleMobileFilters}>
                    <X size={24} />
                  </Button>
                </div>
                {/* Contenu des filtres (m√™me que bureau) */}
                <div className="space-y-6">
                  {/* Prix */}
                  <div>
                    <h3 className="font-medium mb-3">Prix</h3>
                    <div className="px-2">
                      <Slider 
                        defaultValue={[0, 800]} 
                        max={800} 
                        step={1} 
                        value={priceInput}
                        onValueChange={handlePriceChange}
                      />
                      <div className="flex justify-between mt-2 text-sm">
                        <span>{priceInput[0]}‚Ç¨</span>
                        <span>{priceInput[1]}‚Ç¨</span>
                      </div>
                    </div>
                  </div>
                  
                  <Separator />
                  
                  {/* Sous-cat√©gories */}
                  {subCategories.length > 0 && (
                    <div>
                      <h3 className="font-medium mb-3">Sous-cat√©gories</h3>
                      <div className="space-y-2">
                        {subCategories.map((subCat) => (
                          <div key={subCat.id} className="flex items-center">
                            <Checkbox
                              id={`subcat-mobile-${subCat.id}`}
                              checked={selectedSubCategories.includes(subCat.id)}
                              onCheckedChange={() => handleSubCategoryToggle(subCat.id)}
                            />
                            <label htmlFor={`subcat-mobile-${subCat.id}`} className="ml-2 text-sm flex-grow">
                              {subCat.name}
                            </label>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  <Separator />
                  
                  {/* Marques */}
                  <div>
                    <h3 className="font-medium mb-3">Marques</h3>
                    <div className="space-y-2">
                      {brandsLoading ? (
                        <div className="text-center py-2">
                          <div className="animate-spin h-4 w-4 border-b-2 border-primary rounded-full mx-auto"></div>
                          <p className="text-xs text-gray-500 mt-1">Chargement...</p>
                        </div>
                      ) : brandsError ? (
                        <div className="text-xs text-red-500 py-2">{brandsError}</div>
                      ) : brands.length === 0 ? (
                        <div className="text-xs text-gray-500 py-2">Aucune marque disponible</div>
                      ) : (
                        brands.map((brand) => (
                        <div key={brand.id} className="flex items-center">
                          <Checkbox 
                            id={`brand-mobile-${brand.id}`}
                              checked={selectedBrandIds.includes(brand.id)}
                            onCheckedChange={() => handleBrandToggle(brand.id)}
                          />
                          <label 
                            htmlFor={`brand-mobile-${brand.id}`}
                            className="ml-2 text-sm flex-grow"
                          >
                            {brand.name}
                          </label>
                        </div>
                        ))
                      )}
                    </div>
                  </div>
                  
                  <Separator />
                  
                  {/* Disponibilit√© */}
                  <div>
                    <h3 className="font-medium mb-3">Disponibilit√©</h3>
                    <div className="flex items-center justify-between">
                      <label htmlFor="stock-mobile" className="text-sm">
                        En stock uniquement
                      </label>
                      <Switch 
                        id="stock-mobile"
                        checked={inStock}
                        onCheckedChange={setInStock}
                      />
                    </div>
                  </div>
                  
                  <Separator />
                  
                  {/* Promotions */}
                  <div>
                    <h3 className="font-medium mb-3">Promotions</h3>
                    <div className="flex items-center justify-between">
                      <label htmlFor="promos-mobile" className="text-sm">
                        Articles en promotion
                      </label>
                      <Switch 
                        id="promos-mobile"
                        checked={promoOnly}
                        onCheckedChange={setPromoOnly}
                      />
                    </div>
                  </div>
                  
                  <div className="pt-4">
                    <Button className="w-full" onClick={toggleMobileFilters}>
                      Appliquer les filtres
                    </Button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Filtres (desktop) */}
          <div className="hidden md:block w-64 flex-shrink-0">
            <div className="sticky top-24 bg-white rounded-lg border p-5 shadow-sm space-y-6">
              <h2 className="font-bold">Filtres</h2>
              
              {/* Prix */}
              <div>
                <h3 className="font-medium mb-3">Prix</h3>
                <div className="px-2">
                  <Slider 
                    defaultValue={[0, 800]} 
                    max={800} 
                    step={1} 
                    value={priceInput}
                    onValueChange={handlePriceChange}
                  />
                  <div className="flex justify-between mt-2 text-sm">
                    <span>{priceInput[0]}‚Ç¨</span>
                    <span>{priceInput[1]}‚Ç¨</span>
                  </div>
                </div>
              </div>
              
              <Separator />
              
              {/* Sous-cat√©gories */}
              {subCategories.length > 0 && (
                <div>
                  <h3 className="font-medium mb-3">Sous-cat√©gories</h3>
                  <div className="space-y-2">
                    {subCategories.map((subCat) => (
                      <div key={subCat.id} className="flex items-center">
                        <Checkbox
                          id={`subcat-${subCat.id}`}
                          checked={selectedSubCategories.includes(subCat.id)}
                          onCheckedChange={() => handleSubCategoryToggle(subCat.id)}
                        />
                        <label htmlFor={`subcat-${subCat.id}`} className="ml-2 text-sm flex-grow">
                          {subCat.name}
                        </label>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              <Separator />
              
              {/* Marques */}
              <div>
                <h3 className="font-medium mb-3">Marques</h3>
                <div className="space-y-2">
                  {brandsLoading ? (
                    <div className="text-center py-2">
                      <div className="animate-spin h-4 w-4 border-b-2 border-primary rounded-full mx-auto"></div>
                      <p className="text-xs text-gray-500 mt-1">Chargement...</p>
                    </div>
                  ) : brandsError ? (
                    <div className="text-xs text-red-500 py-2">{brandsError}</div>
                  ) : brands.length === 0 ? (
                    <div className="text-xs text-gray-500 py-2">Aucune marque disponible</div>
                  ) : (
                    brands.map((brand) => (
                    <div key={brand.id} className="flex items-center">
                      <Checkbox 
                        id={`brand-${brand.id}`}
                          checked={selectedBrandIds.includes(brand.id)}
                        onCheckedChange={() => handleBrandToggle(brand.id)}
                      />
                      <label 
                        htmlFor={`brand-${brand.id}`}
                        className="ml-2 text-sm flex-grow"
                      >
                        {brand.name}
                      </label>
                    </div>
                    ))
                  )}
                </div>
              </div>
              
              <Separator />
              
              {/* Disponibilit√© */}
              <div>
                <h3 className="font-medium mb-3">Disponibilit√©</h3>
                <div className="flex items-center justify-between">
                  <label htmlFor="stock" className="text-sm">
                    En stock uniquement
                  </label>
                  <Switch 
                    id="stock"
                    checked={inStock}
                    onCheckedChange={setInStock}
                  />
                </div>
              </div>
              
              <Separator />
              
              {/* Promotions */}
              <div>
                <h3 className="font-medium mb-3">Promotions</h3>
                <div className="flex items-center justify-between">
                  <label htmlFor="promos" className="text-sm">
                    Articles en promotion
                  </label>
                  <Switch 
                    id="promos"
                    checked={promoOnly}
                    onCheckedChange={setPromoOnly}
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Produits */}
          <div className="flex-grow">
            {/* En-t√™te de r√©sultats */}
            <div className="flex justify-between items-center mb-6">
              <div>
                <h2 className="text-xl font-semibold">Tous les produits</h2>
                <p className="text-gray-500 text-sm">{filteredProducts.length} produits trouv√©s</p>
              </div>
              <div className="flex items-center gap-2">
                <select className="text-sm border rounded p-2 bg-white">
                  <option>Tri par d√©faut</option>
                  <option>Prix croissant</option>
                  <option>Prix d√©croissant</option>
                  <option>Meilleures ventes</option>
                  <option>Nouveaut√©s</option>
                </select>
              </div>
            </div>
            
            {/* Grille de produits */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
              {isLoading ? (
                <div className="col-span-full flex justify-center items-center h-40">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
                </div>
              ) : error ? (
                <div className="col-span-full bg-red-50 text-red-600 p-4 rounded-md">
                  {error}
                </div>
              ) : filteredProducts.length === 0 ? (
                <div className="col-span-full text-center py-8">
                  <p className="text-lg text-gray-500">Aucun produit trouv√© pour cette cat√©gorie.</p>
                </div>
              ) : (
                paginatedProducts.map((product) => (
                <Card key={product.id} className="overflow-hidden hover:shadow-md transition-shadow duration-300 group">
                    {/* D√©sactiver l'affichage des promos pour l'instant */}
                    {false && (
                    <div className="absolute top-2 left-2 bg-red-500 text-white text-xs font-bold px-2 py-1 rounded-full">
                      PROMO
                    </div>
                  )}
                  <div className="relative h-48 bg-gray-100">
                    <RouterLink to={`/produits/${slugify(product.title, { lower: true })}?categorie=${currentSlug}`}>
                      <img 
                        src={product.image || "/placeholder.svg"} 
                        alt={product.title} 
                        className="w-full h-full object-contain p-4 group-hover:scale-105 transition-transform duration-300"
                      />
                    </RouterLink>
                  </div>
                  <CardContent className="p-4">
                      <RouterLink to={`/produits/${slugify(product.title, { lower: true })}?categorie=${currentSlug}`} className="hover:text-primary">
                      <h3 className="font-medium line-clamp-2 mb-1 h-12">{product.title}</h3>
                    </RouterLink>
                      <p
      className="text-sm text-gray-500 line-clamp-2 mb-2 h-10"
      dangerouslySetInnerHTML={{
        __html: getSafeHtmlDescription(productDescriptions[product.id.toString()])
      }}
    />
                    
                    <div className="flex items-center mb-3">
                        {renderStars(4.5)} {/* Par d√©faut, ou remplacer par une vraie note */}
                        <span className="text-xs ml-1 text-gray-500">(4.5)</span>
                    </div>
                    
                    <div className="flex items-baseline mb-3">
                        {/* Afficher simplement le prix sans promotion pour l'instant */}
                        <span className="text-lg font-bold text-slate-900">{parseFloat(product.price).toFixed(2)}‚Ç¨</span>
                    </div>
                    
                    <div className="flex items-center gap-2 mt-3">
                      <Button 
                        size="sm" 
                        className="flex-grow"
                        onClick={() => handleAddToCart(product)}
                      >
                        <ShoppingCart size={16} className="mr-1" />
                        Ajouter
                      </Button>
                      <Button variant="outline" size="icon">
                        <CheckCircle size={16} />
                      </Button>
                    </div>
                  </CardContent>
                </Card>
                ))
              )}
            </div>
            
            {/* Pagination */}
            {!isLoading && !error && filteredProducts.length > 0 && totalPages > 1 && (
            <div className="mt-10 flex justify-center">
              <nav className="flex items-center gap-1">
                <Button 
                  variant="outline" 
                  size="sm" 
                  disabled={currentPage === 1}
                  onClick={() => setCurrentPage(currentPage - 1)}
                >
                  Pr√©c√©dent
                </Button>
                
                {[...Array(totalPages)].map((_, index) => (
                  <Button
                    key={index}
                    variant={currentPage === index + 1 ? "default" : "outline"}
                    size="sm"
                    onClick={() => setCurrentPage(index + 1)}
                  >
                    {index + 1}
                  </Button>
                ))}
                
                <Button 
                  variant="outline" 
                  size="sm" 
                  disabled={currentPage === totalPages}
                  onClick={() => setCurrentPage(currentPage + 1)}
                >
                  Suivant
                </Button>
              </nav>
            </div>
            )}
          </div>
        </div>
      </main>
      
      <Footer />
    </div>
  );
};

// Petit composant pour g√©rer le lien
function Link({ to, children, className = "" }) {
  return (
    <a href={to} className={`text-white hover:underline ${className}`}>
      {children}
    </a>
  );
}

export default CategoryPage;